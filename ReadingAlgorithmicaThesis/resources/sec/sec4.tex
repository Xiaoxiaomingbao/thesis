
本节为\ref{sec:3}提出的全动态模型设计实现算法。原文6.2节已实现支持任一位的替换的半动态模型，所以这里只需实现任一位的删除和添加操作的情形。

\subsection{删除情形}\label{subsec:del}

由于计算MUPS集合\cite{Manacher75}和LCE\cite{Ukkonen95}的算法都是在线的。可以对内部细微数据结构（如后缀树中的节点和边）进行标记，
从而可以在后面的任意时刻退回到刚读入第$i$位时的状态$S_i$.设外部请求删除第$k$位，则立刻让MUPS集合和LCE退回状态$S_{k-1}$.
又由\cite{Mieno2022}知每次在串尾插入一位，改变的MUPS的数量为常数，且可以在均摊的$O(\log\sigma)$时间内检测到变化并调整MUPS集合。
从原来的第$k+1$位开始重新插入，共经$m = n - k$次插入，若忽略对数因子，则可以在$\tilde{O}(m)$时间内完成对数据结构的调整。

\subsection{添加情形}\label{subsec:add}

仿照\ref{subsec:del}，设外部请求在第$k$位和第$k+1$位的间隔处添加一位，则立刻让MUPS集合和LCE退回状态$S_{k}$.
插入新位，再从原来的第$k+1$位开始重新插入，共经$m = n - k$次插入，若忽略对数因子，则可以在$\tilde{O}(m)$时间内完成对数据结构的调整。

\subsection{回顾与展望}\label{subsec:future}

本节实现的$\tilde{O}(m)$时间复杂度的算法适用于被操作为靠近串尾的情况，如果不满足该条件，则实际的时间复杂度与$O(n)$并无太大差别。
而实际上，每次重新计算MUPS集合、MP集合或LCE也只需要$O(n)$的时间。原文中能设计出比$O(n)$高效的算法，得益于论文\cite{Mieno2022,Mieno2021}
提出了特定情形下修改MUPS集合的高效算法，而这两篇论文中的算法都基于Eertree\cite{RubinchikS18}数据结构。
未来实现高效的全动态模型SUPS算法可能还是要从Eertree着手。
